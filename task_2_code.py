# -*- coding: utf-8 -*-
"""Task 2 Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pbpOcdzafwipTKh4hduvSNkBICVFeMrF

# Solving TSP with ACO

This code is an intial trying for solving the traveling salesman problem using the ant colony optimizer.
"""

import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
np.random.seed(42) # set seed for reproducability

def generate_distances(num_cities):
    distances = np.random.randint(3, 51, size=(num_cities, num_cities))
    distances = np.tril(distances) + np.tril(distances, -1).T
    np.fill_diagonal(distances, 0)
    return distances

# ACO algorithm with separate function for evaporation
def ant_colony_optimization(distances, num_ants, num_iterations, evaporation_rate):
    num_cities = len(distances)
    pheromones = np.ones((num_cities, num_cities))  # Initialize pheromones

    best_path = list()
    best_cost = float('inf')

    optimal_paths = []  # Store optimal paths for every 10th iteration

    def evaporate_pheromones(pheromones, evaporation_rate):
        return pheromones * (1 - evaporation_rate)

    for iteration in range(num_iterations):
        ant_paths = []
        ant_costs = []

        # Generate paths for each ant
        for _ in range(num_ants):
            current_city = np.random.randint(num_cities)
            visited = [current_city]
            path = [current_city]
            cost = 0

            # Build path
            while len(visited) < num_cities:
                unvisited_cities = list(set(range(num_cities)) - set(visited))
                probabilities = np.zeros(len(unvisited_cities))

                # Calculate probabilities for next city
                for i, city in enumerate(unvisited_cities):
                    probabilities[i] = pheromones[current_city][city] / distances[current_city][city]

                # Handle the case where all probabilities are zero (first iter)
                if np.sum(probabilities) == 0:
                    next_city = np.random.choice(unvisited_cities)
                else:
                    # Choose next city based on probabilities
                    next_city = np.random.choice(unvisited_cities, p=probabilities / np.sum(probabilities))

                path.append(next_city)
                visited.append(next_city)
                cost += distances[current_city][next_city]
                current_city = next_city

            # Add return to start city
            path.append(path[0])
            cost += distances[current_city][path[0]]

            ant_paths.append(path)
            ant_costs.append(cost)

        # Evaporate pheromones
        pheromones = evaporate_pheromones(pheromones, evaporation_rate)

        # Update pheromones
        for i in range(num_cities):
            for j in range(num_cities):
                for path, cost in zip(ant_paths, ant_costs):
                    if j in path[i:i+2] or i in path[j:j+2]:
                        pheromones[i][j] += 1 / cost  # Intensification

        # Update best path
        if min(ant_costs) < best_cost:
            best_path = ant_paths[np.argmin(ant_costs)]
            best_cost = min(ant_costs)

        # # Store optimal path and cost for every 10th iteration
        # if (iteration + 1) % 10 == 0:
        #     print(f"\nIteration {iteration + 1}")
        #     print(f"Current Optimal Path: {best_path}, Cost: {best_cost}")

        # # Print pheromone map and current optimal path every 10 iterations
        # if (iteration + 1) % 10 == 0:
        #     print("Pheromone Map:")
        #     sns.heatmap(pheromones, annot=True, fmt=".2f", cmap='YlGnBu')
        #     plt.show()

    return best_path, best_cost

# Plot the graph of cities
def plot_cities_graph(distances, start_city=0):
    num_cities = len(distances)
    G = nx.Graph()

    for i in range(num_cities):
        for j in range(i + 1, num_cities):
            G.add_edge(i, j, weight=distances[i][j])

    pos = nx.spring_layout(G)  # positions for all nodes

    # Nodes
    nx.draw_networkx_nodes(G, pos, node_color='skyblue', node_size=700)
    nx.draw_networkx_nodes(G, pos, nodelist=[start_city], node_color='orange', node_size=700)

    # Edges
    nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5)

    # Labels
    nx.draw_networkx_labels(G, pos, font_size=12, font_family="sans-serif")

    plt.title("Cities Graph")
    plt.axis('off')
    plt.show()

# Highlights best path
def plot_best_path(distances, best_path, start_city=0):
    num_cities = len(distances)
    G = nx.Graph()

    for i in range(num_cities):
        for j in range(i + 1, num_cities):
            G.add_edge(i, j, weight=distances[i][j])

    pos = nx.spring_layout(G)

    # Nodes
    nx.draw_networkx_nodes(G, pos, node_color='skyblue', node_size=700)
    nx.draw_networkx_nodes(G, pos, nodelist=[start_city], node_color='orange', node_size=700)

    # Edges
    nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5)

    # Labels
    nx.draw_networkx_labels(G, pos, font_size=12, font_family="sans-serif")

    # Highlight best path
    edges = [(best_path[i], best_path[i + 1]) for i in range(num_cities - 1)]
    nx.draw_networkx_edges(G, pos, edgelist=edges, width=2.0, edge_color='red')

    plt.title("Best Path")
    plt.axis('off')
    plt.show()

# Generate distances for 10 cities
distances_10_cities= generate_distances(10)
print("Distances for 10 cities:")
print(distances_10_cities)

# Generate distances for 20 cities
distances_20_cities= generate_distances(20)
print("\nDistances for 20 cities:")
print(distances_20_cities)

# List of distances for different numbers of cities
distances_list = [distances_10_cities, distances_20_cities]
num_cities_list = [10, 20]

# Run ACO for different configurations
num_ants_list = [1, 5, 10, 20]
num_iterations = 50

for distances, num_cities in zip(distances_list, num_cities_list):
    for num_ants in num_ants_list:
        print(f"\n================== Running ACO with {num_ants} ants for {num_cities} cities: ======================= \n")
        best_path, best_cost = ant_colony_optimization(distances, num_ants, num_iterations, evaporation_rate = 0.3)
        # print(f"\n================================================================================== \n")

        print(f"Best path for {num_cities} cities: {best_path}, Cost: {best_cost}", "\n")
        plot_cities_graph(distances)
        print("\n")
        plot_best_path(distances, best_path)
        print("\n")
    print("================================================================================\n")